/**
 * @description
 * 对transport后的cmd文件进行解析，查找其子依赖和父依赖（对应缓存）
 * 并记录该文件的最后修改时间
 *
 *
 * @author pakinguo
 */

var FS = require('fs');
var PATH = require('path');
var grunt = require('grunt');


module.exports = function(fileObj, options) {
	var src = fileObj.src[0];

	// 排除已经标记过版本号的文件
	if (/@v/.test(src)) {
		return;
	}

	if (!options.base) {
		console.log('[Error]: '.red + 'options.base is required!');
		return;
	}

	var version;
	if (options.md5) {
		version = 'md5';
	} else {
		version = FS.statSync(src).mtime.getTime() / 1000;
	}

	var _src = fileObj.orig.src[0].replace(/\\|\\\\/g, '/');
	var pattern = _src.substring(_src.indexOf('/') + 1, _src.lastIndexOf('.'));

	// .png .jpg .gif .bmp
	if (/\.(png|jpg|gif|bmp)$/.test(src)) {
		disposeImg(src, pattern, options, version);
	} else if (/\.css$/.test(src)) {
		// .css
		disposeText(src, pattern, options, version, 'css');
	} else if (/\.js/.test(src)) {
		// .js
		disposeText(src, pattern, options, version, 'js');
	} else if (/\.(html|htm|tpl)/.test(src)) {
		// .html .tpl
		// disposeText(src, pattern, options, version, 'view');
	}


}


/**
 * /
 * @param  {[type]}   path     [description]
 * @param  {Function} callback [description]
 * @return {[type]}            [description]
 *
 * @description 
 * 遍历所有文件进行版本号替换
 */
function traverse(path, callback) {
	if (!FS.existsSync(path)) {
		return;
	}
	var ll = FS.readdirSync(path);
	ll.forEach(function(file) {
		var _file = PATH.join(path, file);
		if (FS.statSync(_file).isDirectory()) {
			traverse(_file, callback);
		} else {
			/\.(html|htm|js|css|tpl)$/.test(_file) ? callback(_file) : null;
		}
	});
}


/**
 * /
 * @param  {[type]} src     [description]
 * @param  {[type]} pattern [description]
 * @param  {[type]} options [description]
 * @param  {[type]} version [description]
 * @return {[type]}         [description]
 *
 * @description
 * 图片类型只影响到引用它的其他文件，故其处理逻辑只需要遍历需要遍历的文件夹，匹配影响到的对应的文件
 */
function disposeImg(src, pattern, options, version) {
	// 先生成带版本号的新文件
	var dest = PATH.join(PATH.dirname(src), PATH.basename(src, PATH.extname(src)) + '@v' + version + PATH.extname(src)).replace(/\\|\\\\/g, '/');
	grunt.file.copy(src, dest);

	// 遍历dest所有文件，引用到对应的图片需要
	traverse(options.base, inner);
	options.view ? traverse(options.view, inner) : null;

	function inner(file) {
		// 排除已经标记过版本号的文件
		if(/@v/.test(file)){
			return;
		}

		var mark = false;
		var content = FS.readFileSync(file, 'utf8');
		var matches = content.match(/(src=["']*[^\s"']+\.(png|jpg|gif|bmp)["']*)|(url\([^\s"']+\.(png|jpg|gif|bmp)\))/g);
		if (matches && matches.length > 0) {
			matches.forEach(function(item) {
				var rpath = item.replace(/src=|url\(|\)|["']/g, '');
				var tmp = rpath;

				// 如果是./和../的相对路径，需要合成绝对路径
				if (/^\./.test(rpath)) {
					tmp = PATH.join(PATH.dirname(file), rpath).replace(/\\|\\\\/g, '/');
				}

				// 若存在过滤过的匹配，则做回写操作
				if (new RegExp((pattern + '(.|@)').replace(/\.|\/|\@/g, '\\$&')).test(tmp)) {
					content = content.replace(new RegExp(rpath.replace(/\.|\/|\$|\{|\}/g, '\\$&'), 'g'), PATH.dirname(rpath) + '/' + PATH.basename(src, PATH.extname(src)) + '@v' + version + PATH.extname(rpath));
					mark = true; // 标记需要回写
				}
			})
		}
		if (mark) {
			FS.writeFileSync(file, content, 'utf8');
		}
	}
}


var REGMATCHES, REGREPLACE;

function disposeText(src, pattern, options, version, type) {
	// 根据类型定义匹配的正则
	switch (type) {
		case 'css':
			REGMATCHES = /(href=["'][^\s"']+\.css["']*)|['"][^\s"']+\.css['"]/g;
			REGREPLACE = /href=|['"]/g;
			break;
		case 'js':
			REGMATCHES = /(src=["'][^\s"']+\.js["']*)|['"][^\s"']+\.js['"]|['"][^\s,;]+['"](,|;)/g;
			REGREPLACE = /src=|['",;]/g;
			break;
		case 'view':
			REGMATCHES = /(src=["'][^\s"']+\.js["']*)|['"][^\s"']+\.js['"]|(href=["'][^\s"']+\.css["']*)|['"][^\s"']+\.css['"]/g;
			REGREPLACE = /href=|src=|['",;]/g;
			break;
		default:
			break;
	}

	// 遍历dest所有文件，引用到对应的图片需要
	traverse(options.base, inner);
	options.view ? traverse(options.view, inner) : null;


	// 最后才生成新的带版本号的文件 
	var dest = PATH.join(PATH.dirname(src), PATH.basename(src, PATH.extname(src)) + '@v' + version + PATH.extname(src)).replace(/\\|\\\\/g, '/');
	grunt.file.copy(src, dest);


	function inner(file) {
		if (/@v/.test(file)) {
			return;
		}

		var mark = false;
		var content = FS.readFileSync(file, 'utf8');
		var matches = content.match(REGMATCHES);

		if (matches && matches.length > 0) {
			matches.forEach(function(item) {
				var rpath = item.replace(REGREPLACE, '');
				var tmp = rpath;

				// 如果是./和../的相对路径，需要合成绝对路径
				if (/^\./.test(rpath)) {
					tmp = PATH.join(PATH.dirname(file), rpath).replace(/\\|\\\\/g, '/');
				}

				// 若存在过滤过的匹配，则做回写操作
				if (new RegExp((pattern).replace(/\.|\/|\@/g, '\\$&')).test(tmp)) {
					content = content.replace(new RegExp(rpath.replace(/\.|\/|\@/g, '\\$&'), 'g'), PATH.dirname(rpath) + '/' + PATH.basename(src, PATH.extname(src)) + '@v' + version + PATH.extname(rpath));
					mark = true; // 标记需要回写
				}
			})
		}

		if (mark) {
			FS.writeFileSync(file, content, 'utf8');
		}
	}
}