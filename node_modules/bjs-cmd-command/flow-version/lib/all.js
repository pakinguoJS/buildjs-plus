/**
 * @description
 * 对transport后的cmd文件进行解析，查找其子依赖和父依赖（对应缓存）
 * 并记录该文件的最后修改时间
 *
 *
 * @author pakinguo
 */

var FS = require('fs');
var PATH = require('path');
var grunt = require('grunt');

module.exports = function(fileObj, options) {
	newVersion(fileObj, options);
}



/**
 * /
 * @param  {[type]} src     [description]
 * @param  {[type]} options [description]
 * @return {[type]}         [description]
 */
function newVersion(fileObj, options) {
	var src = fileObj.src[0];
	// 排除已经标记过版本号的文件
	if (/@v/.test(src)) {
		return;
	}

	if (!options.base) {
		process.stdout.write('[Error]: '.red + 'options.base is required!');
		return;
	}

	if (!options.mbase) {
		process.stdout.write('[Error]: '.red + 'options.mbase is required!');
		return;
	}

	var version;
	if (options.md5) {
		version = 'md5';
	} else {
		version = FS.statSync(src).mtime.getTime() / 1000;
	}

	// 提取当前更改的文件路径，并过滤为模块中需要被替换的匹配字符串
	// 这里只提取到模块id，不带后缀，如：xx/js/index.js => xx/js/index
	var _src = fileObj.orig.src[0].replace(/\\|\\\\/g, '/');
	var pattern = _src.substring(_src.indexOf('/') + 1, _src.lastIndexOf('.'));

	// .png .jpg .gif .bmp
	if (/\.(png|jpg|gif|bmp)$/.test(src)) {
		disposeImg(src, pattern, options, version);
	} else if (/\.css$/.test(src)) {
		// .css
		disposeText(src, pattern, options, version, 'css');
	} else if (/\.js/.test(src)) {
		// .js
		disposeText(src, pattern, options, version, 'js');
	} else if (/\.(html|htm|tpl)/.test(src)) {
		// .html .tpl
		disposeSelf(src, options);
	}
}



/**
 * /
 * @param  {[type]}   path     [description]
 * @param  {Function} callback [description]
 * @return {[type]}            [description]
 *
 * @description
 * 遍历所有文件进行版本号替换
 */
function traverse(path, callback) {
	if (!FS.existsSync(path)) {
		return;
	}
	var ll = FS.readdirSync(path);
	ll.forEach(function(file) {
		var _file = PATH.join(path, file).replace(/\\|\\\\/g, '/');
		if (FS.statSync(_file).isDirectory()) {
			traverse(_file, callback);
		} else {
			/\.(html|htm|js|css|tpl)$/.test(_file) ? callback(_file) : null;
		}
	});
}


/**
 * /
 * @param  {[type]} src     [description]
 * @param  {[type]} pattern [description]
 * @param  {[type]} options [description]
 * @param  {[type]} version [description]
 * @return {[type]}         [description]
 *
 * @description
 * 图片类型只影响到引用它的其他文件，故其处理逻辑只需要遍历需要遍历的文件夹，匹配影响到的对应的文件
 */
function disposeImg(src, pattern, options, version) {
	// 先生成带版本号的新文件
	var dest = PATH.join(PATH.dirname(src), PATH.basename(src, PATH.extname(src)) + '@v' + version + PATH.extname(src)).replace(/\\|\\\\/g, '/');
	grunt.file.copy(src, dest);

	// 遍历dest所有文件，引用到对应的图片需要
	traverse(options.base, inner);
	options.view ? traverse(options.view, inner) : null;

	function inner(file) {
		// 排除已经标记过版本号的文件
		if (/@v/.test(file)) {
			return;
		}

		var mark = false;
		var content = FS.readFileSync(file, 'utf8');
		var matches = content.match(/(src=["']*[^\s"']+\.(png|jpg|gif|bmp)["']*)|(url\([^\s"']+\.(png|jpg|gif|bmp)\))/g);
		if (matches && matches.length > 0) {
			matches.forEach(function(item) {
				var rpath = item.replace(/src=|url\(|\)|["']/g, '');
				var tmp = rpath;

				// 如果是./和../的相对路径，需要合成绝对路径
				if (/^\./.test(rpath)) {
					tmp = PATH.join(PATH.dirname(file), rpath).replace(/\\|\\\\/g, '/');
				}

				// 若存在过滤过的匹配，则做回写操作
				if (new RegExp((pattern + '(.|@)').replace(/\.|\/|\@/g, '\\$&')).test(tmp)) {
					content = content.replace(new RegExp(rpath.replace(/\.|\/|\$|\{|\}/g, '\\$&'), 'g'), PATH.dirname(rpath) + '/' + PATH.basename(src, PATH.extname(src)) + '@v' + version + PATH.extname(rpath));
					mark = true; // 标记需要回写
				}
			})
		}
		if (mark) {
			FS.writeFileSync(file, content, 'utf8');
		}
	}
}



function disposeText(src, pattern, options, version, type) {
	var REGMATCHES, REGREPLACE;

	// 根据类型定义匹配的正则
	switch (type) {
		case 'css':
			REGMATCHES = /(href=["'][^\s"']+\.css["']*)|['"][^\s"']+\.css['"]/g;
			REGREPLACE = /href=|['"]/g;
			break;
		case 'js':
			REGMATCHES = /(src=["'][^\s"']+\.js["']*)|(['"][^\s"']+\.js['"])|(['"][^\s,;<>]+['"](,|;))/g;
			REGREPLACE = /src=|['",;]/g;
			break;
		case 'view':
			REGMATCHES = /(src=["'][^\s"']+\.js["']*)|['"][^\s"']+\.js['"]|(href=["'][^\s"']+\.css["']*)|['"][^\s"']+\.css['"]/g;
			REGREPLACE = /href=|src=|['",;]/g;
			break;
		default:
			break;
	}

	// 先预处理本身
	disposeSelf(src, options);

	// 遍历dest所有文件，引用到对应的图片需要
	traverse(options.base, inner);
	options.view ? traverse(options.view, inner) : null;


	// 最后才生成新的带版本号的文件 
	var dest = PATH.join(PATH.dirname(src), PATH.basename(src, PATH.extname(src)) + '@v' + version + PATH.extname(src)).replace(/\\|\\\\/g, '/');
	grunt.file.copy(src, dest);


	function inner(file) {
		if (/@v/.test(file)) {
			return;
		}

		var mark = false;
		var content = FS.readFileSync(file, 'utf8');
		var matches = content.match(REGMATCHES);


		if (matches && matches.length > 0) {
			matches.forEach(function(item) {
				var rpath = item.replace(REGREPLACE, '');
				var tmp = rpath;
				var ext = PATH.extname(rpath);
				/@v/.test(ext) ? ext = ext.substring(0, ext.indexOf('@')) : null;

				// 如果是./和../的相对路径，需要合成绝对路径
				if (/^\./.test(rpath)) {
					tmp = PATH.join(PATH.dirname(file), rpath).replace(/\\|\\\\/g, '/');
				}

				// 若存在过滤过的匹配，则做回写操作
				if (new RegExp((pattern).replace(/\.|\//g, '\\$&')).test(tmp)) {
					content = content.replace(new RegExp(rpath.replace(/\.|\//g, '\\$&'), 'g'), PATH.dirname(rpath) + '/' + PATH.basename(src, PATH.extname(src)) + '@v' + version + ext);
					mark = true; // 标记需要回写
				}
			})
		}

		if (mark) {
			FS.writeFileSync(file, content, 'utf8');
			if (file !== src) {
				// console.log(file, src)
				// 如果文件有变动，除了回写，还需要生成新文件
				var fobj = {};
				fobj.src = [file];
				fobj.orig = {
					src: [PATH.relative(options.base, file).replace(/\\|\\\\/g, '/')]
				}
				newVersion(fobj, options);
			}
			// if (/\.(js|css)$/.test(file)) {
			// 	var v = FS.statSync(file).mtime.getTime() / 1000;
			// 	FS.writeFileSync(PATH.join(PATH.dirname(file), PATH.basename(file, PATH.extname(file)) + '@v' + v + PATH.extname(file)), content, 'utf8');
			// }
		}
	}
}


/**
 * /
 * @param  {[type]} src     [description]
 * @param  {[type]} options [description]
 * @return {[type]}         [description]
 * @description
 * 本身
 */
function disposeSelf(src, options) {
	var content = FS.readFileSync(src, 'utf8');
	var pattern = /src=["'][^\s"']+\.js["']*|['"][^\s"']+\.js['"]|href=["'][^\s"']+\.css["']*|['"][^\s"']+\.css['"]/g;
	var replacePattern = /href=|src=|['",;]/g;

	var matches = content.match(pattern);

	if (matches && matches.length > 0) {
		matches.forEach(function(item) {
			var rpath = item.replace(replacePattern, '');
			// 保留需要替换的原始字符串
			var tmp = rpath;
			var ext = PATH.extname(rpath);
			if (/@v/.test(ext)) {
				ext = ext.substring(0, ext.indexOf('@'));
				tmp = tmp.substring(0, tmp.indexOf('@'));
			}

			// 如果是./和../的相对路径，需要合成绝对路径
			if (/^\./.test(tmp)) {
				tmp = PATH.join(PATH.dirname(src), tmp).replace(/\\|\\\\/g, '/');
			} else {
				// 否则，都需要与options.base进行合成路径
				tmp = PATH.join(options.mbase, tmp).replace(/\\|\\\\/g, '/');
			}

			// 若存在文件，则读取其最后修改时间为版本号
			var version;
			if (options.md5) {
				FS.existsSync(tmp) ? version = 'md5' : version = '';
			} else {
				FS.existsSync(tmp) ? version = FS.statSync(tmp).mtime.getTime() / 1000 : version = '';
			}

			content = content.replace(new RegExp(rpath.replace(/\.|\//g, '\\$&'), 'g'), PATH.dirname(rpath) + '/' + PATH.basename(tmp, ext) + (version !== '' ? '@v' + version : '') + ext);
		})
	}

	FS.writeFileSync(src, content, 'utf8');
}